"""
Program to calculate chromosomes DI, HMM states and topological domain coordinates using a parallelized approach.
"""

from time import gmtime, strftime

### Input variables to be updated before running the script

# NOTE! Each normalized contact matrix should be named as "HiCtool_chrI_40kb_normalized_fend" as default from the normalization step.

# 1) List of chromosomes that you are going to parallel process
chr_list = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20', '21', '22', 'X', 'Y']

# 2) Number of threads to be used
threads = len(chr_list) # (under the assumption that you have at least 24 threads available in this case!)   

print "Calculating DI, HMM states and TADs coordinates in parallel using " + str(threads) + " threads..."
print "Start: " + strftime("%Y-%m-%d %H:%M:%S", gmtime())


def compute_parallel_DI(a_chr):
    """
    Compute DI values, HMM states and topological domain coordinates in parallel.
    Parameters:
        a_chr: chromosome number (example for chromosome 1: '1'). These are the values inside chr_list.
    Output: 
        For each chromosome:
        1) txt file containing DI values.
        2) txt file containing HMM states.
        3) txt file containing topological domains coordinates.
    """    
    
    def save_list(a_list, output_file):
        """
        Save a list in a .txt file.
        Parameters:
            a_list: name of the list to save.
            output_file: output file name in txt format.
        Output: 
            .txt file containing the saved list.       
        """
        with open (output_file,'w') as fout:
            n = len(a_list)
            for i in xrange(n):
                fout.write('%s\n' %a_list[i])
    
    def load_matrix(input_file):
        """
        Load a formatted contact matrix from a txt file and parse it.
        Parameters:
            input_file: input file name in txt format (generated by the function 
            "save_matrix")
        Returns: 
            output_matrix: array containing the parsed values stored 
            in the input txt file to build a contact matrix        
        """
        import numpy as np    
        
        with open (input_file,'r') as infile:
            lines = infile.readlines()
            matrix_vect = []        
            for i in lines:
                if i[0] == "0" and i[1] != ".":
                    for k in xrange(int(i[1:-1])):
                        matrix_vect.append(0)
                else:
                    j = i[:-1]            
                    matrix_vect.append(float(j))
      
        k = len(matrix_vect)
        matrix_size = int((-1+np.sqrt(1+8*k))/2)
        
        iu = np.triu_indices(matrix_size)
        output_matrix_1 = np.zeros((matrix_size,matrix_size)) # upper triangular plus the diagonal
        output_matrix_1[iu] = matrix_vect
        
        diag_matrix = np.diag(np.diag(output_matrix_1)) # diagonal
        
        output_matrix_2 = np.transpose(output_matrix_1) # lower triangular plus the diagonal
        
        output_matrix = output_matrix_1 + output_matrix_2 - diag_matrix
        return output_matrix
    
    
    ##### DI VALUES
    contact_matrix = load_matrix('HiCtool_chr' + a_chr + '_40kb_normalized_fend.txt')
    n = contact_matrix.shape[0]

    # Calculation of the DI
    DI = [] # list of the DI for each bin
    len_var = 2000000/40000 # range of upstream or downstream bins to calculate DI

    for locus in xrange(n): # 'locus' refers to a bin
        if locus < len_var:
            A = sum(contact_matrix[locus][:locus])
            B = sum(contact_matrix[locus][locus+1:locus+len_var+1])
        elif locus >= n-len_var:
            A = sum(contact_matrix[locus][locus-len_var:locus])
            B = sum(contact_matrix[locus][locus+1:])
        else:
            A = sum(contact_matrix[locus][locus-len_var:locus])
            B = sum(contact_matrix[locus][locus+1:locus+len_var+1])
    
        E = (A+B)/2 # expected number of reads
    
        if A==0 and B==0:
            di = 0
            DI.append(di)
        else:
            try:
                di = ((B-A)/(abs(B-A)))*((((A-E)**2)/E)+(((B-E)**2)/E))
            except ZeroDivisionError:
                di = 0
            DI.append(di)

    save_list(DI,'HiCtool_chr' + a_chr + '_DI.txt')
    
    
    ##### HMM STATES
    import numpy as np
    import hmmlearn.hmm as hmm
    
    A = DI
    
    # Guessed Transition Matrix
    TRANS_GUESS = np.array([[0.4, 0.3, 0.3],
                             [0.3, 0.4, 0.3],
                             [0.3, 0.3, 0.4]])
    
    # Guessed Emission Matrix   
    EMISS_GUESS = np.array([[0.4, 0.3, 0.3],
                             [0.3, 0.4, 0.3],
                             [0.3, 0.3, 0.4]])
    
    # Observed emissions                  
    emissions = []
    zero_threshold = 0.4;
    
    for i in range(0,len(A)):
        if A[i] >= zero_threshold:
            emissions.append(1)
        elif A[i] <= -zero_threshold:
            emissions.append(2)
        else:
            emissions.append(0)
    
    # Hidden Markov Model with discrete emissions
    model = hmm.MultinomialHMM(n_components=3, init_params="")
    model.transmat_ = TRANS_GUESS
    model.emissionprob_ = EMISS_GUESS
    
    input_observations = np.array([emissions]).T
    model.fit(input_observations) # estimate model parameters
    
    # Find most likely state sequence corresponding to input_onservations using the Viterbi Algorithm
    logprob, likelystates_array = model.decode(input_observations, algorithm="viterbi")
    
    likelystates = likelystates_array.tolist()
    save_list(likelystates, "HiCtool_chr" + a_chr + "_hmm_states.txt")
    
    
    ##### TOPOLOGICAL DOMAIN COORDINATES
    def save_topological_domains(a_matrix, output_file):
        """
        Function to save the topological domains coordinates to text file.
        Each topological domain coordinates (start and end) occupy one row and are
        tab separated.
        Parameters:
            a_matrix (numpy matrix): file to be saved with topological domains coordinates.
            output_file: output file name in txt format.
        """
        def compile_row_string(a_row):
            return str(a_row).strip(']').strip('[').lstrip().replace(' ','\t')
        with open(output_file, 'w') as f:
            for row in a_matrix:
                f.write(compile_row_string(row)+'\n')
    
    bin_size = 40000    
    
    # Start coordinates of the domains
    p = []
    for i in range(1,len(likelystates)):
        if (likelystates[i] == 1 and likelystates[i-1] == 2) or (likelystates[i] == 1 and likelystates[i-1] == 0):
            p.append(i * bin_size)
    
    # End coordinates of the domains
    n = []
    for i in range(1,len(likelystates)-1):
        if (likelystates[i] == 2 and likelystates[i+1] == 1) or (likelystates[i] == 2 and likelystates[i+1] == 0):
            n.append(i * bin_size)
    
    if len(p) == 0 or len(n) == 0:
        print "WARNING! No topological domains can be detected in chromosome " + a_chr
        return
    
    p1 = 0
    n1 = 0
    p2 = 1
    n2 = 1
    
    # Step 1: checking if the first negative values are greater than the first positive value.
    while n[n1] < p[p1]:
        n1 = n1 + 1
        n2 = n2 + 1
    
    # Now we have removed all the first negative values before the first positive one.
    topological_domains = []
    while p1 < len(p)-1 and n1 < len(n)-1:
        # Step 2: checking if there are two consecutive positive values.
        while n[n1] > p[p2] and p2 < len(p)-1:
            p2 = p2 + 1
        # Now we have removed the possible gaps between consecutive positive states.
    
        # Step 3: checking if there are two consecutive negative values.
        while n[n2] < p[p2] and n2 < len(n)-1:
            n1 = n1 + 1
            n2 = n2 + 1
        # Now we have removed the possible gaps between consecutive negative states.
    
        # Step 4: identification of the Topological Domain.
        topological_domains.append([p[p1],n[n1]])
        p1 = p2
        n1 = n2
        p2 = p1 + 1
        n2 = n1 + 1
    
    save_topological_domains(np.matrix(topological_domains),"HiCtool_chr" + a_chr + "_topological_domains.txt")
    

# Multiprocessing code execution
from multiprocessing import Pool

if __name__ == '__main__':
    pool = Pool(processes=threads)             
    pool.map(compute_parallel_DI, chr_list)
    
print "End: " + strftime("%Y-%m-%d %H:%M:%S", gmtime())