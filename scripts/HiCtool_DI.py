"""
Program to:
1) Calculate and plot the observed DI and true DI (Hidden Markov Model).
2) Calculate the topological domains coordinates.

To use this code, normalized contact data must be provided.
"""

chromosomes = {'hg38':{'1':248956422,
               '2':242193529,
               '3':198295559,
               '4':190214555,
               '5':181538259,
               '6':170805979,
               '7':159345973,
               '8':145138636,
               '9':138394717,
               '10':133797422,
               '11':135086622,
               '12':133275309,
               '13':114364328,
               '14':107043718,
               '15':101991189,
               '16':90338345,
               '17':83257441,
               '18':80373285,
               '19':58617616,
               '20':64444167,
               '21':46709983,
               '22':50818468,
               'X':156040895,
               'Y':57227415},
               'mm10':{'1':195471971,
               '2':182113224,
               '3':160039680,
               '4':156508116,
               '5':151834684,
               '6':149736546,
               '7':145441459,
               '8':129401213,
               '9':124595110,
               '10':130694993,
               '11':122082543,
               '12':120129022,
               '13':120421639,
               '14':124902244,
               '15':104043685,
               '16':98207768,
               '17':94987271,
               '18':90702639,
               '19':61431566,
               'X':171031299,
               'Y':91744698}}

def save_list(a_list, output_file):
    """
    Save a list in a .txt file.
    Parameters:
        a_list: name of the list to save.
        output_file: output file name in txt format.
    Output: 
        .txt file containing the saved list.       
    """
    with open (output_file,'w') as fout:
        n = len(a_list)
        for i in xrange(n):
            fout.write('%s\n' %a_list[i])


def load_matrix(input_file):
    """
    Load a formatted contact matrix from a txt file and parse it.
    Parameters:
        input_file: input file name in txt format (generated by the function 
        "save_matrix").
    Returns: 
        output_matrix: array containing the parsed values stored 
        in the input txt file to build a contact matrix.      
    """
    import numpy as np    
    
    print "Loading " + input_file + "..."
    with open (input_file,'r') as infile:
        matrix_vect = []        
        for i in infile:
            if i[0] == "0" and i[1] != ".":
                for k in xrange(int(i[1:-1])):
                    matrix_vect.append(0)
            else:
                j = i[:-1]            
                matrix_vect.append(float(j))
  
    k = len(matrix_vect)
    matrix_size = int((-1+np.sqrt(1+8*k))/2)
    
    iu = np.triu_indices(matrix_size)
    output_matrix_1 = np.zeros((matrix_size,matrix_size)) # upper triangular plus the diagonal
    output_matrix_1[iu] = matrix_vect
    
    diag_matrix = np.diag(np.diag(output_matrix_1)) # diagonal
    output_matrix_2 = np.transpose(output_matrix_1) # lower triangular plus the diagonal
    output_matrix = output_matrix_1 + output_matrix_2 - diag_matrix
    print "Done!"
    return output_matrix
    
    
def load_DI_values(input_file):
    """
    Load a DI txt file generated with "calculate chromosome DI".
    Parameters:
        input_file: input file name in txt format (generated by the function 
        "calculate_chromosome_DI").
    Returns: 
        List of the DI values.        
    """
    import numpy as np
    
    fp = open(input_file,'r+')
    lines = fp.read().split('\n')
    lines = lines[:-1]
    di_values = (np.nan_to_num(np.array(map(float, lines)))).tolist()
    return di_values


def calculate_chromosome_DI(input_contact_matrix, 
                            a_chr):
    """
    Function to calculate the DI values for a chromosome of and save them 
    in a txt file.
    Parameters:
        input_contact_matrix (str | obj): normalized fend contact matrix at a bin size of 40kb passed as a filename (str)
        or an object returned by "normalize_chromosome_fend_data".
        a_chr (str): chromosome number (example for chromosome 1: '1').
    Returns:
        List with the DI values.
    """
    
    if isinstance(input_contact_matrix, str):
        contact_matrix = load_matrix(input_contact_matrix)
    else:
        contact_matrix = input_contact_matrix
        
    print "Calculating DI values..."
    n = contact_matrix.shape[0]

    # Calculation of the DI
    DI = [] # list of the DI for each bin
    len_var = 2000000/40000 # range of upstream or downstream bins to calculate DI

    for locus in xrange(n): # 'locus' refers to a bin
        if locus < len_var:
            A = sum(contact_matrix[locus][:locus])
            B = sum(contact_matrix[locus][locus+1:locus+len_var+1])
        elif locus >= n-len_var:
            A = sum(contact_matrix[locus][locus-len_var:locus])
            B = sum(contact_matrix[locus][locus+1:])
        else:
            A = sum(contact_matrix[locus][locus-len_var:locus])
            B = sum(contact_matrix[locus][locus+1:locus+len_var+1])
    
        E = (A+B)/2 # expected number of reads
        
        if A==0 and B==0:
            di = 0
            DI.append(di)
        else:
            try:
                di = ((B-A)/(abs(B-A)))*((((A-E)**2)/E)+(((B-E)**2)/E))
            except ZeroDivisionError:
                di = 0
            DI.append(di)
    
    save_list(DI,'HiCtool_chr' + a_chr + '_DI.txt')
    print "Done!"
    return DI
    
    
def calculate_chromosome_true_DI(input_file_DI,
                                 a_chr):
    """
    Function to calculate the true DI values for a chromosome and save 
    them in a .txt file.
    Input:
        input_file_DI (str | obj): txt file of the DI values generated with the function "calculate_chromosome_DI" or
        object with the DI values returned by "calculate_chromosome_DI".
        a_chr (str): chromosome number (example for chromosome 1: '1').
    Returns:
        List with the true DI values (HMM states).
    """
    import numpy as np
    import hmmlearn.hmm as hmm
    
    print "Calculating true DI values..."
    if isinstance(input_file_DI,str):
        A = load_DI_values(input_file_DI)
    else:
        A = input_file_DI   
    
    # Guessed Transition Matrix
    TRANS_GUESS = np.array([[0.4, 0.3, 0.3],
                             [0.3, 0.4, 0.3],
                             [0.3, 0.3, 0.4]])
    
    # Guessed Emission Matrix   
    EMISS_GUESS = np.array([[0.4, 0.3, 0.3],
                             [0.3, 0.4, 0.3],
                             [0.3, 0.3, 0.4]])
    
    # Observed emissions                  
    emissions = []
    zero_threshold = 0.4;
    
    for i in range(0,len(A)):
        if A[i] >= zero_threshold:
            emissions.append(1)
        elif A[i] <= -zero_threshold:
            emissions.append(2)
        else:
            emissions.append(0)
    
    # Hidden Markov Model with discrete emissions
    model = hmm.MultinomialHMM(n_components=3, init_params="")
    model.transmat_ = TRANS_GUESS
    model.emissionprob_ = EMISS_GUESS
    
    input_observations = np.array([emissions]).T
    model.fit(input_observations) # estimate model parameters
    
    # Find most likely state sequence corresponding to input_onservations using the Viterbi Algorithm
    logprob, likelystates_array = model.decode(input_observations, algorithm="viterbi")
    
    likelystates = likelystates_array.tolist()
    save_list(likelystates, "HiCtool_chr" + a_chr + "_hmm_states.txt")
    print "Done!"
    return likelystates

def load_hmm_states(input_file):
    """
    Load a hmm txt file generated with "calculate_chromosome_true_DI".
    Parameters:
        input_file: input file name in txt format (generated by the function 
        "calculate_chromosome_true_DI").
    Returns: 
        List of the hmm states.    
    """
    fp = open(input_file,'r+')
    lines = fp.read().split('\n')
    lines = lines[:-1]
    likelystates = map(int,lines)
    return likelystates

def plot_chromosome_DI(input_file_DI, 
                       a_chr, 
                       start_pos, 
                       end_pos,
                       input_file_hmm='',
                       species='hg38',
                       plot_legend=True,
                       plot_grid=True):
    """
    Function to plot the DI and true DI values for a chromosome.
    Parameters:
        input_file_DI (str | obj): txt file of the DI values generated with the function "calculate_chromosome_DI" or
        object with the DI values returned by "calculate_chromosome_DI".
        a_chr (str): chromosome number (example for chromosome 1: '1').
        start_pos (int): start coordinate for the plot in bp.
        end_pos (int): end coordinate for the plot in bp.
        input_file_hmm (str | obj): txt file of the true DI values generated with the function "calculate_chromosome_true_DI" or
        object with the true DI values returned by "calculate_chromosome_true_DI.
        species (str): species name (hg38, mm10, etc.).
        plot_legend (bool): if True, plot the legend.
        plot_grid (bool): if True, plot the grid.
    """    
    import numpy as np
    import matplotlib.pyplot as plt
    import matplotlib
    matplotlib.use('Agg')
    
    bin_size = 40000
    start_index = int(round(start_pos/bin_size))
    end_index = int(round((end_pos)/bin_size))
    
    if species == 'hg38' or species == 'mm10':
        if end_pos > (chromosomes[species][a_chr]/bin_size)*bin_size and end_pos < chromosomes[species][a_chr]:
            end_pos = (chromosomes[species][a_chr]/bin_size)*bin_size
        elif end_pos > chromosomes[species][a_chr]:
            print("ERROR: end coordinate exceeds chromosome dimension")
            return
    
    if isinstance(input_file_DI,str):
        DI = load_DI_values(input_file_DI)
    else:
        DI = input_file_DI   
        
    DI_part = DI[start_index:end_index]

    x = np.arange(start_pos,end_pos,bin_size)
    width = bin_size/1.5
    pos_DI = np.array(DI_part)
    neg_DI = np.array(DI_part)
    pos_DI[pos_DI <= 0] = np.nan
    neg_DI[neg_DI > 0] = np.nan
    
    if input_file_hmm == '':
        print "Plotting DI values..."

        plt.close("all")
        plt.bar(x, pos_DI, width, color="r", label="Positive DI")
        plt.bar(x, neg_DI, width, color="g", label="Negative DI")
        plt.xlim([x[0]-bin_size*8,x[-1]+bin_size*8])
        plt.ylim([min(DI_part)-25,max(DI_part)+25])
        plt.title("Directionality Index " + species + " [Chr " + a_chr +": " + str(start_pos) + "-" + str(end_pos) + "]")
        plt.xlabel("Base coordinates")
        plt.ylabel("Directionality Index (DI) values")
        plt.grid(plot_grid)
        if plot_legend == True:
            plt.legend()
        plt.savefig("HiCtool_chr" + a_chr + "_DI.pdf", format = 'pdf')
        print "Done!"
    
    else:
        print "Plotting DI and true DI values..."     
        
        if isinstance(input_file_hmm,str):
            likelystates = load_hmm_states(input_file_hmm)
        else:
            likelystates = input_file_hmm
    
        DI_true = []
        for i in range(0,len(likelystates)):
            if likelystates[i] == 1:
                DI_true.append(min(DI_part)-12)
            elif likelystates[i] == 2:
                DI_true.append(min(DI_part)-15)
            else:
                DI_true.append(0)
        
        DI_true_part = DI_true[start_index:end_index]
        
        # Plot
        pos_DI_true = np.array(DI_true_part)
        neg_DI_true = np.array(DI_true_part)
        pos_DI_true[pos_DI_true != min(DI_part)-12] = np.nan
        neg_DI_true[neg_DI_true != min(DI_part)-15] = np.nan
        
        plt.close("all")
        plt.bar(x, pos_DI, width, color="r", label="Positive DI")
        plt.bar(x, neg_DI, width, color="g", label="Negative DI")
        plt.plot(x, pos_DI_true, marker=">", color="r", label="Positive true DI")
        plt.plot(x, neg_DI_true, marker="<", color="g", label="Negative true DI")
        plt.xlim([x[0]-bin_size*8,x[-1]+bin_size*8])
        plt.ylim([min(DI_part)-25,max(DI_part)+25])
        plt.title("Directionality Index " + species + " [Chr " + a_chr +": " + str(start_pos) + "-" + str(end_pos) + "]")
        plt.xlabel("Base coordinates")
        plt.ylabel("Directionality Index (DI) values")
        plt.grid(plot_grid)
        if plot_legend == True:
            plt.legend()
        plt.savefig("HiCtool_chr" + a_chr + "_DI_full.pdf", format = 'pdf')
        print "Done!"

def save_topological_domains(a_matrix, output_file):
    """
    Function to save the topological domains coordinates to text file.
    Each topological domain coordinates (start and end) occupy one row and are
    tab separated.
    Parameters:
        a_matrix (numpy matrix): file to be saved with topological domains coordinates.
        output_file: output file name in txt format.
    """
    def compile_row_string(a_row):
        return str(a_row).strip(']').strip('[').lstrip().replace(' ','\t')
    with open(output_file, 'w') as f:
        for row in a_matrix:
            f.write(compile_row_string(row)+'\n')


def load_topological_domains(input_file):
    """
    Function to load the topological domains coordinates from txt file.
    Parameters:
        input_file: input file name generated with "calculate_topological_domains" in txt format.
    Returns:
        List of lists with topological domain coordinates.
    """
    import csv
    print "Loading topological domain coordinates..."
    with open(input_file, 'r') as f:
        reader = csv.reader(f, dialect='excel', delimiter='\t')
        topological_domains = []
        for row in reader:
            row_int = [int(x) for x in row]
            topological_domains.append(row_int)
        return topological_domains
    print "Done!"

def calculate_chromosome_topological_domains(input_file_hmm,
                                             a_chr):
    """
    Function to calculate the topological domains coordinates of a chromosome. 
    Topological domains are stored in each line with tab separated start and end coordinates.
    Parameters:
        input_file_hmm (str | obj): txt file of the true DI values generated with the function "calculate_chromosome_true_DI" or
        object with the true DI values returned by "calculate_chromosome_true_DI.
        a_chr (str): chromosome number (example for chromosome 1: '1').
    Returns:
        List of lists with topological domain coordinates.
    """
    import numpy as np    
    
    print "Calculating topological domain coordinates..."
    if isinstance(input_file_hmm,str):
        likelystates = load_hmm_states(input_file_hmm)
    else:
        likelystates = input_file_hmm
    
    bin_size = 40000    
    
    # Start coordinates of the domains
    p = []
    for i in range(1,len(likelystates)):
        if (likelystates[i] == 1 and likelystates[i-1] == 2) or (likelystates[i] == 1 and likelystates[i-1] == 0):
            p.append(i * bin_size)
    
    # End coordinates of the domains
    n = []
    for i in range(1,len(likelystates)-1):
        if (likelystates[i] == 2 and likelystates[i+1] == 1) or (likelystates[i] == 2 and likelystates[i+1] == 0):
            n.append(i * bin_size)
    
    if len(p) == 0 or len(n) == 0:
        print "WARNING! No topological domains can be detected in chromosome " + a_chr
        return
    
    p1 = 0
    n1 = 0
    p2 = 1
    n2 = 1
    
    # Step 1: checking if the first negative values are greater than the first positive value.
    while n[n1] < p[p1]:
        n1 = n1 + 1
        n2 = n2 + 1
    
    # Now we have removed all the first negative values before the first positive one.
    topological_domains = []
    while p1 < len(p)-1 and n1 < len(n)-1:
        # Step 2: checking if there are two consecutive positive values.
        while n[n1] > p[p2] and p2 < len(p)-1:
            p2 = p2 + 1
        # Now we have removed the possible gaps between consecutive positive states.
    
        # Step 3: checking if there are two consecutive negative values.
        while n[n2] < p[p2] and n2 < len(n)-1:
            n1 = n1 + 1
            n2 = n2 + 1
        # Now we have removed the possible gaps between consecutive negative states.
    
        # Step 4: identification of the Topological Domain.
        topological_domains.append([p[p1],n[n1]])
        p1 = p2
        n1 = n2
        p2 = p1 + 1
        n2 = n1 + 1
    
    save_topological_domains(np.matrix(topological_domains),"HiCtool_chr" + a_chr + "_topological_domains.txt")
    print "Done!"
    return topological_domains